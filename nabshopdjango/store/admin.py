from django.contrib import admin, messages
from django.db.models.aggregates import Count
from django.db.models.query import QuerySet
from django.urls import reverse
from django.utils.html import format_html, urlencode

from . import models


# custom filter
class StockFilter(admin.SimpleListFilter):
  title = 'stock'  # By stock
  parameter_name = 'stock' # used in the query string

  # define different settings
  def lookups(self, request, model_admin):
    return [
      ('<10', 'LOW') # a tuple is a setting, '<10' used to do the filtering and 'LOW' is for human readibility
    ]
  
  # implement the filtering logic here
  def queryset(self, request, queryset: QuerySet):
    if (self.value() == '<10'):
      return queryset.filter(stock__lt=10)


@admin.register(models.Genre)
class GenreAdmin(admin.ModelAdmin):
  list_display = ['title', 'books_count']
  search_fields = ['title']

  @admin.display(ordering="books_count")
  def books_count(self, genre):
    # return genre.books_count
    # add html links to other pages
    # like http://127.0.0.1/admin/store/book/?genre__id=2
    # django uses reverse to generate the url
    # reverse(admin:appname_model_page)
    # query string generated by urlencode is appended to the url to have filters
    # url is in () to break the code into multiple lines
    url = (
      reverse('admin:store_book_changelist')
            + '?'
            + urlencode({
                'genre__id': str(genre.id)
            }))
    return format_html('<a href="{}">{} Books</a>', url, genre.books_count)

  # because there is no books_counts in genre that we returned
  # we override the query
  def get_queryset(self, request):
    return super().get_queryset(request).annotate(
      books_count=Count('books')
      )

@admin.register(models.Book)
class BookAdmin(admin.ModelAdmin):
  """Customize the list page of books"""
  list_display = ['title', 'author', 'genre_title']
  # preload the related_fields
  list_select_related = ['genre']
  # add filtering panel on the right 
  list_filter = ['genre', 'updated_at']
  # set this search field to use autocomple in BOokEditionAdmin
  search_fields = ['title']

  # genre__title belongs to another table
  # this function imports it in the BookAdmin table
  def genre_title(self, book):
    return book.genre.title


@admin.register(models.Author)
class AuthorAdmin(admin.ModelAdmin):
  list_display = ['first_name', 'last_name', 'country']


@admin.register(models.BookEdition)
class BookEditionAdmin(admin.ModelAdmin):
  # auto populated a field from another
  prepopulated_fields = {
    'slug': ['isbn']  
  }
  # convert dropdown list in the form to autocomplete field
  # set the fields of autocompleting as search_fields in
  # the table that has that field
  autocomplete_fields = ['book']
  list_display = ['book_title', 'booktype', 'isbn', 'unit_price', 'publisher', 'stock_status']
  list_editable = ['unit_price']
  list_per_page = 10
  # fields = ['', ''] # fields to show the admin in form to update, create...
  # exclude = ['', ''] # fields to not show the admin in form to update, create...
  # readonly_fields = ['', ''] # fields will not be edited
  actions = ['clear_stock']
  # add filtering pannel on the right
  # create the custom filter StockFilter
  # as a class outside called StockFilter
  # and add it here
  list_filter = ['booktype', StockFilter]
  search_fields = ['book_title']
  
  # create a custom action
  # first create this method and add the actions
  # to the attributes
  @admin.action(description='Clear stock')
  # queryset contains objects selected by user
  def clear_stock(self, request, queryset):
    updated_count = queryset.update(stock=0)
    # show a message to the user
    self.message_user(
      request,
      f'{updated_count} books were successfully updated.',
      messages.ERROR # message type, error or debug or info... ...
    )

  def book_title(self, bookedition):
    return bookedition.book.title

  # to order on a field that was computed, use @
  # defined the function that computes the custom field
  @admin.display(ordering='stock')
  def stock_status(self, bookedition):
    if bookedition.stock < 10:
      return 'Low'
    return 'OK'


@admin.register(models.Publisher)
class PublisherAdmin(admin.ModelAdmin):
  list_display = ['publisherhouse', 'country', 'city']


@admin.register(models.Customer)
class CustomerAdmin(admin.ModelAdmin):
  list_display = ['first_name', 'last_name', 'orders']
  list_per_page = 10
  list_select_related = ['user']
  ordering = ['user__first_name', 'user__last_name']
  search_fields = ['first_name__istartswith', 'last_name__istartswith']
  autocomplete_fields = ['user']

  @admin.display(ordering='orders_count')
  def orders(self, customer):
        url = (
            reverse('admin:store_order_changelist')
            + '?'
            + urlencode({
                'customer__id': str(customer.id)
            }))
        return format_html('<a href="{}">{} Orders</a>', url, customer.orders_count)

  def get_queryset(self, request):
    return super().get_queryset(request).annotate(
      orders_count=Count('orders'))


# manage order display either with TabularInline or
# Stacked Inline. Create a class to set the inline config
# and add the inlines setting in the OrderAdmin
class OrderItemInline(admin.TabularInline):
    autocomplete_fields = ['bookedition']
    min_num = 1
    max_num = 10
    model = models.OrderItem  # the objects to display
    extra = 0  # don't want to see any placehoder rows

@admin.register(models.Order)
class OrderAdmin(admin.ModelAdmin):
  list_display = ['id', 'placed_at', 'customer']
  list_per_page = 10
  list_select_related = ['customer']
  autocomplete_fields = ['customer']
  inlines = [OrderItemInline]
  
